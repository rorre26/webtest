<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Telegram Pong</title>
  <style>
    html,body { margin:0; height:100%; background:#111; color:#eee; font-family:system-ui,Arial; }
    #wrap { display:flex; flex-direction:column; align-items:center; gap:8px; padding:10px; }
    canvas { background:#000; display:block; width:100%; max-width:600px; border:1px solid #333; }
    .row { display:flex; gap:8px; flex-wrap:wrap; justify-content:center; }
    button { padding:8px 12px; border:1px solid #444; background:#1e1e1e; color:#eee; cursor:pointer; }
    input { padding:8px 12px; background:#1e1e1e; border:1px solid #444; color:#eee; width:260px; }
    small { opacity:.7 }
  </style>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
</head>
<body>
<div id="wrap">
  <h2>Ping-Pong (Telegram Mini App)</h2>
  <div class="row">
    <button id="createRoom">Создать комнату</button>
    <input id="roomId" placeholder="ROOM_ID" />
    <button id="joinRoom">Подключиться</button>
  </div>
  <small id="status">not connected</small>
  <canvas id="game" width="600" height="360"></canvas>
</div>

<script>
const tg = window.Telegram.WebApp;
tg.expand();

// ==== конфиг ====
const WS_URL = "wss://YOUR_WORKER_SUBDOMAIN.workers.dev/ws"; // <— вставьте адрес WebSocket из шага с Worker
const BOT_USERNAME = "YOUR_BOT_USERNAME"; // без @, для инвайт-ссылки

// ==== парсим room из startapp ====
const startParam = tg?.initDataUnsafe?.start_param || "";
const roomInput = document.getElementById('roomId');
if (startParam) roomInput.value = startParam;

// ==== UI ====
const $status = document.getElementById('status');
const $create = document.getElementById('createRoom');
const $join = document.getElementById('joinRoom');
const canvas = document.getElementById('game');
const ctx = canvas.getContext('2d');

// ==== состояние игры ====
const W = canvas.width, H = canvas.height;
const paddleW = 10, paddleH = 70;
const ballR = 6;

let me = { y: H/2 - paddleH/2, score:0 };     // моя ракетка (левая)
let other = { y: H/2 - paddleH/2, score:0 };  // соперник (правая)
let ball = { x: W/2, y: H/2, vx: 3, vy: 2 };
let isHost = false; // хозяин комнаты симулирует мяч
let connected = false;
let ws;

// управление — тач/мышь
let dragging = false;
canvas.addEventListener('pointerdown', ()=> dragging=true);
canvas.addEventListener('pointerup', ()=> dragging=false);
canvas.addEventListener('pointermove', (e)=>{
  if (!dragging) return;
  const rect = canvas.getBoundingClientRect();
  const y = (e.clientY - rect.top) * (canvas.height/rect.height);
  me.y = Math.max(0, Math.min(H - paddleH, y - paddleH/2));
  send({ type:"paddle", y: me.y });
});

// кнопки
$create.onclick = () => {
  const id = Math.random().toString(36).slice(2,8);
  roomInput.value = id;
  connect(id, true);
  const link = `https://t.me/${BOT_USERNAME}/app?startapp=${id}`;
  tg.showPopup({ title:"Инвайт", message:`Отправь другу ссылку:\n${link}`, buttons:[{type:"ok"}]});
};
$join.onclick = () => {
  if (!roomInput.value) return alert("Укажи ROOM_ID");
  connect(roomInput.value, false);
};

// соединение
function connect(room, host) {
  isHost = host;
  ws = new WebSocket(`${WS_URL}?room=${encodeURIComponent(room)}`);
  ws.onopen = () => { connected = true; $status.textContent = `room ${room} — connected (${isHost?'host':'guest'})`; send({type:"hello"}); };
  ws.onclose = () => { connected = false; $status.textContent = "disconnected"; };
  ws.onmessage = (ev) => {
    const msg = JSON.parse(ev.data || "{}");
    if (msg.type === "paddle" && typeof msg.y === "number") {
      other.y = msg.y;
    }
    if (msg.type === "ball" && !isHost) {
      // гость принимает положение мяча от хоста
      Object.assign(ball, msg.ball);
    }
  };
}
function send(obj) { if (ws && ws.readyState===1) ws.send(JSON.stringify(obj)); }

// игровой луп
function step() {
  // физика мяча ведётся у хоста
  if (connected && isHost) {
    ball.x += ball.vx; ball.y += ball.vy;
    if (ball.y < ballR || ball.y > H - ballR) ball.vy *= -1;

    // коллизии с ракетками
    if (ball.x < 20 && ball.y > me.y && ball.y < me.y + paddleH) { ball.vx = Math.abs(ball.vx); }
    if (ball.x > W-20 && ball.y > other.y && ball.y < other.y + paddleH) { ball.vx = -Math.abs(ball.vx); }

    // гол
    if (ball.x < 0) { other.score++; resetBall(1); }
    if (ball.x > W) { me.score++; resetBall(-1); }

    // шлём состояние гостю ~60 раз/сек
    send({ type:"ball", ball });
  }

  draw();
  requestAnimationFrame(step);
}
function resetBall(dir) {
  ball = { x: W/2, y: H/2, vx: 3*dir, vy: (Math.random()>0.5?2:-2) };
}
function draw() {
  ctx.clearRect(0,0,W,H);
  // середина
  ctx.fillStyle = "#333"; for (let y=0;y<H;y+=16) ctx.fillRect(W/2-1,y,2,8);
  // мяч
  ctx.fillStyle = "#fff"; ctx.beginPath(); ctx.arc(ball.x,ball.y,ballR,0,Math.PI*2); ctx.fill();
  // ракетки
  ctx.fillRect(8, me.y, paddleW, paddleH);
  ctx.fillRect(W - paddleW - 8, other.y, paddleW, paddleH);
  // счёт
  ctx.fillText(`${me.score} : ${other.score}`, W/2 - 10, 16);
}
requestAnimationFrame(step);
</script>
</body>
</html>

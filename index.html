<!doctype html>
<html lang="ru">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Telegram Pong — Mini App (serverless test)</title>
  <script src="https://telegram.org/js/telegram-web-app.js"></script>
  <style>
    :root { --bg:#0f1115; --fg:#eaeef5; --muted:#9aa4b2; --acc:#4f8cff; }
    *{box-sizing:border-box} body{margin:0;font-family:system-ui,-apple-system,Segoe UI,Roboto,Inter,Helvetica,Arial,sans-serif;background:var(--bg);color:var(--fg);} 
    header{padding:16px;border-bottom:1px solid #202432;display:flex;align-items:center;gap:12px}
    h1{font-size:18px;margin:0;font-weight:600}
    main{display:grid;grid-template-columns:320px 1fr;gap:16px;max-width:1100px;margin:0 auto;padding:16px}
    @media (max-width:900px){ main{grid-template-columns:1fr} }
    .card{background:#131722;border:1px solid #1e2230;border-radius:16px;padding:14px;box-shadow:0 4px 16px rgba(0,0,0,.25)}
    .row{display:flex;gap:10px;flex-wrap:wrap}
    button{appearance:none;border:0;border-radius:12px;padding:10px 14px;font-weight:600;cursor:pointer;background:var(--acc);color:white}
    button.secondary{background:#1f2533;color:var(--fg)}
    label{font-size:12px;color:var(--muted);display:block;margin-bottom:6px}
    textarea, input[type="text"]{width:100%;background:#0f1320;border:1px solid #23293a;border-radius:12px;padding:10px;color:var(--fg);min-height:64px}
    .hint{font-size:12px;color:var(--muted)}
    canvas{width:100%;max-width:720px;aspect-ratio:16/9;background:#0a0c12;border:1px solid #1f2432;border-radius:16px;display:block;margin:0 auto}
    .kbd{padding:2px 6px;border-radius:6px;background:#22283a;color:#c9d3e7;font-size:12px}
    .pill{display:inline-block;background:#1f2533;color:#c9d3e7;padding:2px 8px;border-radius:999px;font-size:12px}
    .status{font-size:13px}
  </style>
</head>
<body>
  <header>
    <svg width="22" height="22" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M3 12a9 9 0 1018 0 9 9 0 10-18 0z" stroke="#4f8cff" stroke-width="2"/><path d="M10 8h4v8h-4z" fill="#4f8cff"/><path d="M8 10h8v4H8z" fill="#4f8cff" opacity=".5"/></svg>
    <h1>Telegram Pong — Mini App</h1>
    <span class="pill">serverless test via WebRTC</span>
  </header>

  <main>
    <section class="card" id="panel">
      <div style="display:flex;align-items:center;justify-content:space-between;margin-bottom:8px">
        <strong>Сеть/инвайт</strong>
        <span class="status" id="netStatus">offline</span>
      </div>

      <div class="row" style="margin-bottom:12px">
        <button id="btnPractice">Practice (бот)</button>
        <button id="btnHost">Host match</button>
        <button id="btnJoin" class="secondary">Join match</button>
      </div>

      <div id="hostBox" style="display:none">
        <label>1) Отправь другу этот инвайт-код</label>
        <textarea id="offerOut" readonly></textarea>
        <div class="row" style="margin:8px 0 12px">
          <button id="btnShare" class="secondary">Поделиться в Telegram</button>
          <button id="btnCopy" class="secondary">Скопировать</button>
        </div>
        <label>2) Вставь сюда «answer» от друга</label>
        <textarea id="answerIn" placeholder="Вставь ответ друга и нажми ‘Apply answer’"></textarea>
        <div class="row" style="margin-top:8px"><button id="btnApplyAnswer">Apply answer</button></div>
      </div>

      <div id="joinBox" style="display:none">
        <label>1) Вставь «offer» от хоста</label>
        <textarea id="offerIn" placeholder="Вставь сюда код приглашения (offer)"></textarea>
        <div class="row" style="margin-top:8px"><button id="btnMakeAnswer">Сгенерировать answer</button></div>
        <label style="margin-top:10px">2) Отправь этот answer хосту</label>
        <textarea id="answerOut" readonly></textarea>
        <div class="row" style="margin:8px 0 12px"><button id="btnCopyAnswer" class="secondary">Скопировать answer</button></div>
      </div>

      <p class="hint">Это тест без сервера: соединение через <b>WebRTC</b>, сигнализацию передаем вручную копи‑пастой в Телеграме. Работает в пределах одного Интернета/CGNAT тоже часто ок. Для продакшена позже добавишь нормальный сигналинг (WS/Workers).</p>

      <hr style="border:none;border-top:1px solid #1e2230;margin:12px 0">
      <div>
        <strong>Управление</strong>
        <div class="hint">ПК: <span class="kbd">W</span>/<span class="kbd">S</span> (лево) и <span class="kbd">↑</span>/<span class="kbd">↓</span> (право). Мобильный: свайп/тап по своей половине.
        </div>
      </div>
    </section>

    <section class="card">
      <canvas id="game" width="960" height="540"></canvas>
      <div class="row" style="justify-content:space-between;margin-top:8px">
        <div class="hint" id="gameStatus">Mode: idle</div>
        <div class="hint" id="latency"></div>
      </div>
    </section>
  </main>

<script>
(function(){
  const tg = window.Telegram?.WebApp;
  try { tg && tg.expand(); } catch(e){}

  // --- Small helpers
  const $ = id => document.getElementById(id);
  const enc = obj => btoa(unescape(encodeURIComponent(JSON.stringify(obj))));
  const dec = str => JSON.parse(decodeURIComponent(escape(atob(str.trim()))));

  // --- UI elements
  const btnPractice = $('btnPractice');
  const btnHost = $('btnHost');
  const btnJoin = $('btnJoin');
  const netStatus = $('netStatus');
  const gameStatus = $('gameStatus');
  const latencyEl = $('latency');

  const hostBox = $('hostBox');
  const joinBox = $('joinBox');

  const offerOut = $('offerOut');
  const answerIn = $('answerIn');
  const offerIn = $('offerIn');
  const answerOut = $('answerOut');

  const btnShare = $('btnShare');
  const btnCopy = $('btnCopy');
  const btnApplyAnswer = $('btnApplyAnswer');
  const btnMakeAnswer = $('btnMakeAnswer');
  const btnCopyAnswer = $('btnCopyAnswer');

  // --- Game state
  const cvs = $('game');
  const ctx = cvs.getContext('2d');
  const W = cvs.width, H = cvs.height;
  const PADDLE_W = 12, PADDLE_H = 90, BALL = 12;

  let mode = 'idle'; // idle | practice | host | join | online
  let isHost = false;
  let mySide = 'left'; // left/right

  const state = {
    ball: {x: W/2, y: H/2, vx: 4, vy: 3},
    left: {y: H/2 - PADDLE_H/2, vy:0, score:0},
    right:{y: H/2 - PADDLE_H/2, vy:0, score:0}
  };

  // AI for practice
  function aiStep(){
    const target = state.ball.y - PADDLE_H/2;
    const speed = 4.0;
    state.right.y += Math.sign(target - state.right.y) * speed;
    clampPaddles();
  }

  function clampPaddles(){
    state.left.y = Math.max(0, Math.min(H-PADDLE_H, state.left.y));
    state.right.y = Math.max(0, Math.min(H-PADDLE_H, state.right.y));
  }

  function stepPhysics(){
    // move ball
    state.ball.x += state.ball.vx;
    state.ball.y += state.ball.vy;

    // walls
    if (state.ball.y < 0 || state.ball.y > H-BALL) state.ball.vy *= -1;

    // paddles
    const bx = state.ball.x, by = state.ball.y;
    // left paddle
    if (bx < 30 && bx > 30-PADDLE_W && by+BALL>state.left.y && by<state.left.y+PADDLE_H) {
      state.ball.vx = Math.abs(state.ball.vx) + 0.2;
      const rel = (by + BALL/2) - (state.left.y + PADDLE_H/2);
      state.ball.vy = Math.max(-6, Math.min(6, rel*0.15));
    }
    // right paddle
    if (bx+BALL > W-30 && bx < W-30+PADDLE_W && by+BALL>state.right.y && by<state.right.y+PADDLE_H) {
      state.ball.vx = -Math.abs(state.ball.vx) - 0.2;
      const rel = (by + BALL/2) - (state.right.y + PADDLE_H/2);
      state.ball.vy = Math.max(-6, Math.min(6, rel*0.15));
    }

    // score
    if (state.ball.x < -20){ state.right.score++; resetBall(1); }
    if (state.ball.x > W+20){ state.left.score++; resetBall(-1); }
  }

  function resetBall(dir){
    state.ball.x = W/2; state.ball.y = H/2;
    const speed = 4 + Math.random()*1.5;
    state.ball.vx = speed * (dir<0 ? -1 : 1);
    state.ball.vy = (Math.random()*2-1)*3;
  }

  function draw(){
    ctx.clearRect(0,0,W,H);
    // middle line
    ctx.globalAlpha = .25; ctx.fillStyle = '#92a2c9';
    for(let y=0;y<H;y+=24){ ctx.fillRect(W/2-2,y,4,12); }
    ctx.globalAlpha = 1; ctx.fillStyle = '#eaf1ff';
    // paddles
    ctx.fillRect(30-PADDLE_W, state.left.y, PADDLE_W, PADDLE_H);
    ctx.fillRect(W-30, state.right.y, PADDLE_W, PADDLE_H);
    // ball
    ctx.fillRect(state.ball.x, state.ball.y, BALL, BALL);
    // score
    ctx.font = '32px system-ui, Arial'; ctx.textAlign='center';
    ctx.fillText(state.left.score, W/2-60, 40);
    ctx.fillText(state.right.score, W/2+60, 40);
  }

  // input
  let keys = {};
  window.addEventListener('keydown', e=>{ keys[e.key]=true; });
  window.addEventListener('keyup', e=>{ keys[e.key]=false; });
  cvs.addEventListener('pointerdown', onTouch);
  cvs.addEventListener('pointermove', onTouch);
  function onTouch(e){
    const rect = cvs.getBoundingClientRect();
    const y = (e.clientY - rect.top) * (H/rect.height) - PADDLE_H/2;
    if (mySide==='left' && e.clientX-rect.left < rect.width/2) state.left.y = y;
    if (mySide==='right'&& e.clientX-rect.left > rect.width/2) state.right.y = y;
    clampPaddles();
  }

  function localControlStep(){
    // WASD / Arrows
    if (mySide==='left'){
      if (keys['w']||keys['W']) state.left.y -= 6;
      if (keys['s']||keys['S']) state.left.y += 6;
    } else {
      if (keys['ArrowUp']) state.right.y -= 6;
      if (keys['ArrowDown']) state.right.y += 6;
    }
    clampPaddles();
  }

  // --- WebRTC (manual signalling)
  let pc, dc; let lastPing=0; let rtt=0;

  function setupPeer(isHostRole){
    isHost = isHostRole; mySide = isHost? 'left':'right';
    pc = new RTCPeerConnection({iceServers:[{urls:'stun:stun.l.google.com:19302'}]});
    pc.onicecandidate = e=>{ if(!e.candidate) updateInvite(); };
    pc.onconnectionstatechange = ()=> updateNet();
    pc.ondatachannel = (ev)=>{ dc = ev.channel; wireDC(); };
    if (isHost){ dc = pc.createDataChannel('game'); wireDC(); }
  }

  function wireDC(){
    dc.onopen = ()=>{ netStatus.textContent = 'online'; mode='online'; gameStatus.textContent = 'Mode: online'; };
    dc.onclose= ()=>{ netStatus.textContent = 'disconnected'; };
    dc.onmessage = (ev)=>{
      const msg = JSON.parse(ev.data);
      if (msg.type==='state' && !isHost){ Object.assign(state, msg.state); }
      if (msg.type==='input'){
        // remote paddle position
        if (isHost){ if (mySide==='left') state.right.y = msg.y; else state.left.y = msg.y; }
      }
      if (msg.type==='pong'){ rtt = Date.now()-msg.t; latencyEl.textContent = `RTT ${rtt} ms`; }
    };
  }

  function updateNet(){ netStatus.textContent = pc.connectionState || 'unknown'; }

  function updateInvite(){
    if (!pc?.localDescription) return;
    const data = enc({ sdp: pc.localDescription.sdp, type: pc.localDescription.type });
    if (isHost) offerOut.value = data; else answerOut.value = data;
  }

  async function makeOffer(){ setupPeer(true); const offer = await pc.createOffer(); await pc.setLocalDescription(offer); updateInvite(); }
  async function applyRemoteAnswer(){ try{ const ans = dec(answerIn.value); await pc.setRemoteDescription(new RTCSessionDescription(ans)); }catch(e){ alert('Неверный answer'); } }
  async function acceptOfferAndAnswer(){ try{ setupPeer(false); const off = dec(offerIn.value); await pc.setRemoteDescription(new RTCSessionDescription(off)); const ans = await pc.createAnswer(); await pc.setLocalDescription(ans); updateInvite(); }catch(e){ alert('Неверный offer'); } }

  // share helper
  btnShare.onclick = ()=>{
    const text = encodeURIComponent('Зайди в игру Pong и вставь этот offer-код:\n\n'+offerOut.value.substring(0,1800));
    if (tg && tg.openTelegramLink){ tg.openTelegramLink('https://t.me/share/url?text='+text); }
    else window.open('https://t.me/share/url?text='+text,'_blank');
  };
  btnCopy.onclick = ()=>{ offerOut.select(); document.execCommand('copy'); };
  btnCopyAnswer.onclick = ()=>{ answerOut.select(); document.execCommand('copy'); };

  // buttons
  btnPractice.onclick = ()=>{ mode='practice'; mySide='left'; isHost=true; gameStatus.textContent='Mode: practice vs bot'; };
  btnHost.onclick = async ()=>{ hostBox.style.display='block'; joinBox.style.display='none'; mode='host'; gameStatus.textContent='Mode: host (waiting for answer)'; await makeOffer(); };
  btnJoin.onclick = ()=>{ joinBox.style.display='block'; hostBox.style.display='none'; mode='join'; gameStatus.textContent='Mode: join (paste offer)'; };
  btnApplyAnswer.onclick = ()=> applyRemoteAnswer();
  btnMakeAnswer.onclick = ()=> acceptOfferAndAnswer();

  // main loop
  function loop(){
    // controls
    localControlStep();

    if (mode==='practice'){
      aiStep(); stepPhysics();
    } else if (mode==='online'){
      // send my paddle position
      if (dc && dc.readyState==='open'){
        const y = (mySide==='left')? state.left.y : state.right.y;
        dc.send(JSON.stringify({type:'input', y}));
        // ping
        if (!lastPing || Date.now()-lastPing>1000){ lastPing=Date.now(); dc.send(JSON.stringify({type:'pong', t:lastPing})); }
      }
      if (isHost){ stepPhysics(); // host authoritative
        // broadcast state 30fps
        if (dc && dc.readyState==='open'){
          if (!loop._last || performance.now()-loop._last>33){ loop._last=performance.now(); dc.send(JSON.stringify({type:'state', state})); }
        }
      }
    }

    draw();
    requestAnimationFrame(loop);
  }
  loop();
})();
</script>
</body>
</html>
